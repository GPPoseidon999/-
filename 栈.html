<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>栈</title>
</head>

<body>
    <script>
        function Stack() {
            this.dataStore = []; //保存栈内元素
            this.top = 0;        //标记可以插入新元素的位置栈内压入元素该变量变大弹出元素变量减小
            this.push = push;    //入栈操作
            this.pop = pop;      //出栈操作
            this.peek = peek;    //返回栈顶元素
            this.clear = clear;  //清空栈
            this.length = length;//栈的长度
        }

        //向栈中压入元素 同时让指针top+1 一定是++
        function push(element) {
            this.dataStore[this.top++] = element;
        }

        //出栈操作 同时将top-1
        function pop() {
            return this.dataStore[--this.top];
        }

        //返回栈顶元素，便令top值减1 返回不删除
        function peek() {
            return this.dataStore[this.top - 1];
        }

        //返回栈内元素的元素个数
        function length() {
            return this.top;
        }

        //清空一个栈
        function clear() {
            this.top = 0;
        }

        var s = new Stack;
        s.push("小明第一");
        s.push("小红第二");
        s.push("小王第三");
        s.push("小红第四");
        console.log("栈的长度", s.length());
        console.log("栈顶", s.peek());
        console.log("出栈", s.pop());
    
    // -----------回文算法------dad 10001  resdser--------
    function isPalindrome(word){
        var s=new Stack();
        for(var i=0;i<word.length;i++){
            s.push(word[i]);
        }
        var rword="";
        console.log(s);
        while(s.length()>0){
            rword+=s.pop();
        }
        console.log(rword)
        if(rword==word){
            return true;
        }else{
            return false;
        }
    }

    var word="racecar";
    alert(isPalindrome(word));
    </script>
</body>

</html>